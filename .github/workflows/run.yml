# This is a basic workflow that is manually triggered

name: Run

env:
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
  aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  aws_region: ${{ secrets.AWS_DEFAULT_REGION }}
# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:

  setup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@master
      - name: Create a pod inside cluster who is in charge of the cluster administration
        uses: ./.github/actions/kubectl
        env:
          USE_THE_GITHUB_CI_KUBECTL: >
            Yeah!
            We just need a basic kubectl to send our .yml files!
            Next steps will require more processing power, though.
            And in those cases, we are going to send over our scripts
            over to the pod we are now creating. They will get run there,
            inside t2.2xlarge AWS nodes, and with low latency against the
            ECR inside our EKS cluster.
        with:
          args: "apply -f .github/workflows/aws/admin"
      - name: Send greeting 3
        uses: ./.github/actions/kubectl
        env:
          REPO_NAME: "AkkaPersistenceCassandraBenchmark"
        with:
          args: "git clone ${{ github.repository }} ${{ REPO_NAME}}; cd ${{ REPO_NAME }}; ls; echo 'Done' "